#lang racket

(define (read-bingo ip)
  (let ((calls (map string->number (string-split (read-line ip) ","))))
    (let loop ((cur (read-line ip)) (boards '()))
      (if (eof-object? cur)
          (values calls boards)
          (for/fold ((board '())
                     #:result (loop (read-line ip) (append boards (list (make-immutable-hash board)))))
                    ((i (in-list '(0 1 2 3 4))))
            (for/fold ((row (map string->number (string-split (read-line ip))))
                       (assocs '())
                       #:result (append assocs board))
                      ((j (in-list '(0 1 2 3 4))))
              (values (cdr row) (cons (cons (cons i j) (car row)) assocs))))))))

(define (board-row board n)
  (let ((keys (map (lambda (x) (cons n x)) '(0 1 2 3 4 ))))
    (map (lambda (x) (hash-ref board x)) keys)))
(define (board-column board n)
  (let ((keys (map (lambda (x) (cons x n)) '(0 1 2 3 4 ))))
    (map (lambda (x) (hash-ref board x)) keys)))

(define (bingo? board)
   (let loop ((i 0))
     (cond ((>= i 5) #f)
           ((or (null? (filter number? (board-row board i)))
                (null? (filter number? (board-column board i))))
            #t)
           (else (loop (add1 i))))))

(define (mark-board b n)
  (let loop ((keys (hash-keys b)))
    (cond ((null? keys) b)
          ((equal? n (hash-ref b (car keys))) (hash-update b (car keys) number->string))
          (else (loop (cdr keys))))))

(define (board-score board call)
  (* call
     (apply + (filter number? (hash-values board)))))

(define (play-bingo calls boards)
  (let loop ((rem calls) (b boards))
    (if (null? rem) '()
        (let ((next (map (lambda (x) (mark-board x (car rem))) b)))
          (let ((winners (filter bingo? next)))
            (if (null? winners)
                (loop (cdr rem) next)
                (board-score (car winners) (car rem))))))))

(define (loser-board calls boards)
  (let loop ((rem-c calls) (rem-b boards))
    (cond ((null? rem-c) '())
          ((null? (cdr rem-b))
           (let i-loop ((i-rem-c rem-c) (b (car rem-b)) (last-call 0))
             (if (bingo? b)
                 (board-score b last-call)
                 (i-loop (cdr i-rem-c) (mark-board b (car i-rem-c)) (car i-rem-c)))))
          (else (loop (cdr rem-c)
                      (filter (lambda (x) (not (bingo? x)))
                                          (map (lambda (y) (mark-board y (car rem-c))) rem-b)))))))

(call-with-values (lambda () (call-with-input-file "day4.txt" read-bingo)) loser-board)
    